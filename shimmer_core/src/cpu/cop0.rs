use super::COP;
use crate::cpu::Reg;
use bitos::bitos;
use strum::FromRepr;
use zerocopy::{FromBytes, Immutable, IntoBytes};

#[derive(Debug, Clone, Copy, PartialEq, Eq, FromRepr)]
pub enum Interrupt {
    VBlank = 0x00,
    GPU = 0x01,
    CDROM = 0x02,
    DMA = 0x03,
    Timer0 = 0x04,
    Timer1 = 0x05,
    Timer2 = 0x06,
    ControllerAndMemCard = 0x07,
    SIO = 0x08,
    SPU = 0x09,
    Controller = 0xA,
}

#[bitos(32)]
#[derive(Clone, Copy, Default, FromBytes, IntoBytes)]
pub struct InterruptStatus {
    #[bits(0..10)]
    status: [bool; 10],
}

impl std::fmt::Debug for InterruptStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_set()
            .entries(
                self.status()
                    .iter()
                    .enumerate()
                    .filter_map(|(i, requested)| {
                        requested.then_some(Interrupt::from_repr(i).unwrap())
                    }),
            )
            .finish()
    }
}

impl InterruptStatus {
    #[inline]
    pub fn request(&mut self, interrupt: Interrupt) {
        self.set_status_at(interrupt as usize, true);
    }

    #[inline]
    pub fn mask(&mut self, mask: &InterruptMask) -> Self {
        let status_bits: u32 = self.0;
        let mask_bits: u32 = mask.0;
        let masked = status_bits & mask_bits;

        Self::from_bits(masked)
    }

    #[inline]
    pub fn requested(&self) -> Option<Interrupt> {
        let trailing = self.0.trailing_zeros();
        (trailing < 10).then(|| match trailing {
            0x00 => Interrupt::VBlank,
            0x01 => Interrupt::GPU,
            0x02 => Interrupt::CDROM,
            0x03 => Interrupt::DMA,
            0x04 => Interrupt::Timer0,
            0x05 => Interrupt::Timer1,
            0x06 => Interrupt::Timer2,
            0x07 => Interrupt::ControllerAndMemCard,
            0x08 => Interrupt::SIO,
            0x09 => Interrupt::SPU,
            0x0A => Interrupt::Controller,
            _ => unreachable!(),
        })
    }
}

#[bitos(32)]
#[derive(Clone, Copy, Default, FromBytes, IntoBytes)]
pub struct InterruptMask {
    #[bits(0..10)]
    enabled: [bool; 10],
}

// impl mem::Reg for InterruptMask {
//     type Primitive = u32;
//     const ADDRESS: Address = Address(0x1F80_1074);
//
//     fn read(&self) -> Self::Primitive {
//         self.0
//     }
//
//     fn write(&mut self, value: Self::Primitive) {
//         self.0 = value;
//     }
// }

impl std::fmt::Debug for InterruptMask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_set()
            .entries(
                self.enabled()
                    .iter()
                    .enumerate()
                    .filter_map(|(i, enabled)| enabled.then_some(Interrupt::from_repr(i).unwrap())),
            )
            .finish()
    }
}

#[bitos(5)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Exception {
    Interrupt = 0x00,
    TlbModification = 0x01,
    TlbLoad = 0x02,
    TlbStore = 0x03,
    /// Happens when data is loaded from outside KUSEG in user mode and when the address is
    /// misaligned.
    AddressErrorLoad = 0x04,
    /// Happens when data is stored to outside KUSEG in user mode and when the address is
    /// misaligned.
    AddressErrorStore = 0x05,
    BusErrorInstruction = 0x06,
    BusErrorData = 0x07,
    /// Generated by the SYSCALL instruction.
    Syscall = 0x08,
    Breakpoint = 0x09,
    ReservedInstruction = 0x0A,
    CopUnusable = 0x0B,
    ArithmeticOverflow = 0x0C,
}

// TODO: cause needs a write mask - it's read only!! (except bits 8 and 9)

/// Represents the value of the CAUSE register. It describes the most recently recognised
/// exception, and is also used to request interrupts.
#[bitos(32)]
#[derive(Debug, Clone, FromBytes, IntoBytes, Immutable)]
pub struct Cause {
    /// Contains the exception that ocurred.
    #[bits(2..7)]
    pub exception: Option<Exception>,
    /// Used to request a CPU interrupt if it is enabled in the System Register. In the PSX,
    /// there's only one interrupt line connected, which is the third entry in this array.
    #[bits(8..16)]
    pending_interrupt_lines: [bool; 8],
    /// The coprocessor that caused this exception if it ocurred because of a coprocessor
    /// instruction for a coprocessor that wasn't enabled in the System Register.
    #[bits(28..30)]
    pub coprocessor: Option<COP>,
    /// If set, indicates that `EPC` does not point to the actual instruction that caused the
    /// exception, but rather to the instruction preceding it, because it was in a delay slot.
    #[bits(31..32)]
    pub branch_delay: bool,
}

impl Cause {
    #[inline]
    pub fn interrupt_pending(&self) -> bool {
        self.pending_interrupt_lines_at(2).unwrap()
    }

    #[inline]
    pub fn set_interrupt_pending(&mut self, value: bool) {
        self.set_pending_interrupt_lines_at(2, value);
    }
}

/// Represents the state of the CPU before an exception happened.
#[bitos(2)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CpuState {
    #[bits(0..1)]
    interrupts_enabled: bool,
    #[bits(1..2)]
    user_mode: bool,
}

/// Represents the value of the System Status register
#[bitos(32)]
#[derive(Debug, Clone, FromBytes, IntoBytes, Immutable)]
pub struct SystemStatus {
    #[bits(0..6)]
    pub cpu_state_stack: [CpuState; 3],
    /// Contains which interrupt lines are permitted to fire a CPU interrupt. In the PSX,
    /// there's only one interrupt line connected, which is the third entry in this array.
    #[bits(8..16)]
    pub enabled_interrupt_lines: [bool; 8],
    #[bits(16..17)]
    pub isolate_cache: bool,
    #[bits(17..18)]
    pub swap_cache: bool,
    // pz: u1,
    // cm: u1,
    // pe: u1,
    // ts: u1,
    #[bits(22..23)]
    pub boot_exception_vectors_in_kseg1: bool,
    #[bits(28..29)]
    pub cop0_enabled_in_user_mode: bool,
    #[bits(29..30)]
    pub cop1_enabled: bool,
    #[bits(30..31)]
    pub cop2_enabled: bool,
    #[bits(31..32)]
    pub cop3_enabled: bool,
}

impl SystemStatus {
    /// Disables interrupts, goes into kernel mode and pushes the new [`CpuState`] onto the state stack.
    pub fn start_exception(&mut self) {
        let mut stack = self.cpu_state_stack();
        stack.copy_within(0..2, 1);
        stack[0] = CpuState::from_bits(Default::default());
        self.set_cpu_state_stack(stack);
    }

    /// Pops the [`CpuState`] from the state stack.
    pub fn restore_from_exception(&mut self) {
        let mut stack = self.cpu_state_stack();
        stack.copy_within(1..3, 0);
        self.set_cpu_state_stack(stack);
    }

    /// Whether interrupts are currently enabled or not.
    pub fn interrupts_enabled(&self) -> bool {
        self.enabled_interrupt_lines_at(2).unwrap()
            && self.cpu_state_stack_at(0).unwrap().interrupts_enabled()
    }
}

#[derive(Clone)]
pub struct Registers(pub(super) [u32; 32]);

impl std::fmt::Debug for Registers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Registers")
            .field_with("gp", |f| {
                let mut map = f.debug_map();
                for i in 0..32 {
                    if self.0[i as usize] != 0 {
                        map.entry(
                            &unsafe { std::mem::transmute::<u8, Reg>(i) },
                            &self.0[i as usize],
                        );
                    }
                }

                map.finish_non_exhaustive()
            })
            .finish()
    }
}

impl Default for Registers {
    fn default() -> Self {
        let mut regs: [_; 32] = Default::default();
        regs[Reg::COP0_SR as usize] = 0x1090_0000;

        Self(regs)
    }
}

impl Registers {
    pub fn read(&self, reg: Reg) -> u32 {
        self.0[reg as usize]
    }

    pub fn write(&mut self, reg: Reg, value: u32) {
        self.0[reg as usize] = value;
        self.0[0] = 0;
    }

    pub fn system_status(&self) -> &SystemStatus {
        zerocopy::transmute_ref!(&self.0[Reg::COP0_SR as usize])
    }

    pub fn system_status_mut(&mut self) -> &mut SystemStatus {
        zerocopy::transmute_mut!(&mut self.0[Reg::COP0_SR as usize])
    }

    pub fn cause(&self) -> &Cause {
        zerocopy::transmute_ref!(&self.0[Reg::COP0_CAUSE as usize])
    }

    pub fn cause_mut(&mut self) -> &mut Cause {
        zerocopy::transmute_mut!(&mut self.0[Reg::COP0_CAUSE as usize])
    }
}

#[derive(Debug, Clone, Default)]
pub struct State {
    pub regs: Registers,
    pub interrupt_status: InterruptStatus,
    pub interrupt_mask: InterruptMask,
}
