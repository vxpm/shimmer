//! Items related to the coprocessor 0 (COP0). It is responsible for exception handling and keeping
//! track of the CPU state.

use super::COP;
use super::RegLoad;
use crate::cpu::Reg;
use bitos::BitUtils;
use bitos::bitos;

/// A CPU exception kind.
#[bitos(5)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Exception {
    Interrupt = 0x00,
    TlbModification = 0x01,
    TlbLoad = 0x02,
    TlbStore = 0x03,
    /// Happens when data is loaded from outside KUSEG in user mode and when the address is
    /// misaligned.
    AddressErrorLoad = 0x04,
    /// Happens when data is stored to outside KUSEG in user mode and when the address is
    /// misaligned.
    AddressErrorStore = 0x05,
    BusErrorInstruction = 0x06,
    BusErrorData = 0x07,
    /// Generated by the SYSCALL instruction.
    Syscall = 0x08,
    Breakpoint = 0x09,
    ReservedInstruction = 0x0A,
    CopUnusable = 0x0B,
    ArithmeticOverflow = 0x0C,
}

/// Represents the value of the CAUSE register. It describes the most recently recognised
/// exception and is also used to request CPU interrupts.
#[bitos(32)]
#[derive(Debug, Clone)]
pub struct Cause {
    /// Contains the exception that ocurred.
    #[bits(2..7)]
    pub exception: Option<Exception>,
    /// Used to request a CPU interrupt if it is enabled in the System Register. In the PSX,
    /// there's only one interrupt line connected, which is the third entry in this array: it is
    /// connected to the system interrupt controller.
    #[bits(8..16)]
    pub pending_interrupt_lines: [bool; 8],
    /// The coprocessor that caused this exception if it ocurred because of a coprocessor
    /// instruction for a coprocessor that wasn't enabled in the System Register.
    #[bits(28..30)]
    pub coprocessor: Option<COP>,
    /// If set, indicates that `EPC` does not point to the actual instruction that caused the
    /// exception, but rather to the instruction preceding it, because it was in a delay slot.
    #[bits(31..32)]
    pub branch_delay: bool,
}

impl Cause {
    /// Returns whether a system interrupt is currently pending.
    #[inline(always)]
    pub fn system_interrupt_pending(&self) -> bool {
        self.pending_interrupt_lines_at(2).unwrap()
    }

    /// Sets a system interrupt as pending.
    #[inline(always)]
    pub fn set_system_interrupt_pending(&mut self, value: bool) {
        self.set_pending_interrupt_lines_at(2, value);
    }
}

/// Represents the mode of the CPU.
#[bitos(2)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CpuMode {
    #[bits(0)]
    interrupts_enabled: bool,
    #[bits(1)]
    user_mode: bool,
}

/// Represents the value of the System Status register.
#[bitos(32)]
#[derive(Debug, Clone)]
pub struct SystemStatus {
    #[bits(0..6)]
    pub cpu_mode_stack: [CpuMode; 3],
    /// Contains which interrupt lines are allowed to fire a CPU interrupt. In the PSX, there's
    /// only one interrupt line connected, which is the third entry in this array: it is connected
    /// to the system interrupt controller.
    #[bits(8..16)]
    pub enabled_interrupt_lines: [bool; 8],
    #[bits(16..17)]
    pub isolate_cache: bool,
    #[bits(17..18)]
    pub swap_cache: bool,
    // pz: u1,
    // cm: u1,
    // pe: u1,
    // ts: u1,
    #[bits(22)]
    pub boot_exception_vectors_in_kseg1: bool,
    #[bits(28)]
    pub cop0_enabled_in_user_mode: bool,
    #[bits(29)]
    pub cop1_enabled: bool,
    #[bits(30)]
    pub cop2_enabled: bool,
    #[bits(31)]
    pub cop3_enabled: bool,
}

impl SystemStatus {
    /// Disables interrupts, goes into kernel mode and pushes the new [`CpuMode`] onto the mode
    /// stack.
    pub fn start_exception(&mut self) {
        let mut stack = self.cpu_mode_stack();
        stack.copy_within(0..2, 1);
        stack[0] = CpuMode::from_bits(Default::default());
        self.set_cpu_mode_stack(stack);
    }

    /// Pops the current [`CpuMode`] from the state stack.
    pub fn restore_from_exception(&mut self) {
        let mut stack = self.cpu_mode_stack();
        stack.copy_within(1..3, 0);
        self.set_cpu_mode_stack(stack);
    }

    /// Whether system interrupts are currently enabled or not.
    pub fn system_interrupts_enabled(&self) -> bool {
        self.enabled_interrupt_lines_at(2).unwrap()
            && self.cpu_mode_stack_at(0).unwrap().interrupts_enabled()
    }
}

/// The registers of COP0.
#[derive(Clone)]
pub struct Registers([u32; 32]);

impl std::fmt::Debug for Registers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Registers")
            .field_with("gp", |f| {
                let mut map = f.debug_map();
                for i in 0..32 {
                    if self.0[i as usize] != 0 {
                        map.entry(
                            &unsafe { std::mem::transmute::<u8, Reg>(i) },
                            &self.0[i as usize],
                        );
                    }
                }

                map.finish_non_exhaustive()
            })
            .finish()
    }
}

impl Default for Registers {
    fn default() -> Self {
        let mut regs: [_; 32] = Default::default();
        regs[Reg::COP0_SR as usize] = 0x1090_0000;

        Self(regs)
    }
}

impl Registers {
    #[inline(always)]
    pub fn read(&self, reg: Reg) -> u32 {
        self.0[reg as usize]
    }

    #[inline(always)]
    pub fn write(&mut self, reg: Reg, value: u32) {
        match reg {
            Reg::COP0_CAUSE => {
                self.0[reg as usize] = self.0[reg as usize].with_bits(8, 10, value.bits(8, 10))
            }
            _ => self.0[reg as usize] = value,
        }
    }

    #[inline(always)]
    pub fn system_status(&self) -> &SystemStatus {
        zerocopy::transmute_ref!(&self.0[Reg::COP0_SR as usize])
    }

    #[inline(always)]
    pub fn system_status_mut(&mut self) -> &mut SystemStatus {
        zerocopy::transmute_mut!(&mut self.0[Reg::COP0_SR as usize])
    }

    #[inline(always)]
    pub fn cause(&self) -> &Cause {
        zerocopy::transmute_ref!(&self.0[Reg::COP0_CAUSE as usize])
    }

    #[inline(always)]
    pub fn cause_mut(&mut self) -> &mut Cause {
        zerocopy::transmute_mut!(&mut self.0[Reg::COP0_CAUSE as usize])
    }
}

/// The state of COP0.
#[derive(Debug, Clone, Default)]
pub struct Cop0 {
    pub regs: Registers,
    // TODO: move this to interpreter
    pub load_delay_slot: Option<RegLoad>,
}
